#!/usr/bin/env node

var argv = require('minimist')(process.argv.slice(2), {
  boolean: ['dryRun', 'ignoreEmpty', 'csv', 'headerline']
});

var mongojs = require('mongojs');
var csv = require('csv-parser');
var EJSON = require('mongodb-extended-json');
var async = require('async');
var debug = require('debug')('mongomerge');
var update = require('../')

var ignoreEmpty = argv.ignoreEmpty;
var isCsv = argv.csv;

header = argv.header == null? true : argv.header
ignoreEmpty = argv.ignoreEmpty == null? true : argv.ignoreEmpty;
dryRun = argv.dryRun == null ? false : argv.dryRun;

if (!argv.c)
  fail('-c [collection] required');

var updated = 0;
var db = mongojs(argv.d || 'test', [argv.c]);
var collection = db.collection(argv.c);

function handle(data, done) {
  update(collection, data.record, {
    ignoreEmpty: ignoreEmpty,
    dryRun: dryRun
  }, function (err, doc) {
    updated += doc.n
    done(err, doc)
  })
}

queue = async.queue(handle, argv.j || 20);

// TODO (jb55): fix csv parser
var parser = isCsv ? csv : EJSON.createParseStream.bind(null, false)

process.stdin
.pipe(parser())
.on('data', function(record) {
  queue.push({ record: record }, function(err){
    if (err)
      console.error("ERROR: %s", err);
  });
})

queue.drain = function(){
  console.error("%s documents updated", updated);
  debug("draining");
  db.close();
};

function fail(msg) {
  console.error(msg);
  process.exit(1);
}
